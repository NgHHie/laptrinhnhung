#include <Arduino.h>
#include <WiFi.h>
#include <PubSubClient.h>

// ====== WiFi & MQTT config ======
const char* ssid = "KawaII";
const char* password = "dmcayvcl";
const char* mqtt_server = "172.20.10.2"; // IP m√°y ch·∫°y Node.js server

WiFiClient espClient;
PubSubClient client(espClient);

// ====== L298N setup ======
int rightIN1 = 27;
int rightIN2 = 26;
int leftIN3 = 32;  // ƒê√£ thay ƒë·ªïi t·ª´ 25 sang 32
int leftIN4 = 33;
int rightEnable = 14;
int leftEnable = 12;

const int freq = 1000;
const int pwmChannelRight = 0;
const int pwmChannelLeft = 1;
const int resolution = 8;
int dutyCycle = 200;

String mqttCommand = "";
String currentState = "stop"; // Bi·∫øn l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i

// ====== Encoder setup ======
const int encoderPin = 18;  // Ch√¢n k·∫øt n·ªëi encoder
volatile long encoderCount = 0;
unsigned long lastPublishTime = 0;
const unsigned long publishInterval = 500; // Gi·∫£m xu·ªëng 500ms ƒë·ªÉ c·∫≠p nh·∫≠t th∆∞·ªùng xuy√™n h∆°n
const int pulsesPerRotation = 20; // ƒêi·ªÅu ch·ªânh th√¥ng s·ªë n√†y theo encoder c·ªßa b·∫°n

// ====== Auto Movement Control ======
bool autoModeEnabled = false;
int autoModeStep = 0;
long targetEncoderCount = 0;
long startEncoderCount = 0;
unsigned long stateChangeTime = 0;
const unsigned long pauseDuration = 1000; // Th·ªùi gian d·ª´ng gi·ªØa c√°c b∆∞·ªõc (1 gi√¢y)
bool inPauseState = false;

// H√†m ng·∫Øt ƒë·∫øm xung encoder
void IRAM_ATTR encoderISR() {
  encoderCount++;
}

void stop() {
  digitalWrite(rightIN1, LOW);
  digitalWrite(rightIN2, LOW);
  digitalWrite(leftIN3, LOW);
  digitalWrite(leftIN4, LOW);
  Serial.println("‚õî ƒê√£ d·ª´ng");
}

void moveForward() {
  digitalWrite(rightIN1, LOW);
  digitalWrite(rightIN2, HIGH);
  digitalWrite(leftIN3, LOW);
  digitalWrite(leftIN4, HIGH);
  ledcWrite(pwmChannelRight, dutyCycle);
  ledcWrite(pwmChannelLeft, dutyCycle);
  Serial.println("‚û°Ô∏è Ti·∫øn");
}

void moveBackward() {
  digitalWrite(rightIN1, HIGH);
  digitalWrite(rightIN2, LOW);
  digitalWrite(leftIN3, HIGH);
  digitalWrite(leftIN4, LOW);
  ledcWrite(pwmChannelRight, dutyCycle);
  ledcWrite(pwmChannelLeft, dutyCycle);
  Serial.println("‚¨ÖÔ∏è L√πi");
}

void turnLeft() {
  digitalWrite(rightIN1, LOW);
  digitalWrite(rightIN2, HIGH);
  digitalWrite(leftIN3, HIGH);
  digitalWrite(leftIN4, LOW);
  ledcWrite(pwmChannelRight, dutyCycle);
  ledcWrite(pwmChannelLeft, dutyCycle);
  Serial.println("‚Ü™Ô∏è Tr√°i");
}

void turnRight() {
  digitalWrite(rightIN1, HIGH);
  digitalWrite(rightIN2, LOW);
  digitalWrite(leftIN3, LOW);
  digitalWrite(leftIN4, HIGH);
  ledcWrite(pwmChannelRight, dutyCycle);
  ledcWrite(pwmChannelLeft, dutyCycle);
  Serial.println("‚Ü©Ô∏è Ph·∫£i");
}

void moveLeft() {
  digitalWrite(rightIN1, LOW);
  digitalWrite(rightIN2, HIGH);
  digitalWrite(leftIN3, LOW);
  digitalWrite(leftIN4, HIGH);
  ledcWrite(pwmChannelRight, dutyCycle);
  ledcWrite(pwmChannelLeft, dutyCycle / 2);
  Serial.println("‚¨ÖÔ∏è D·ªãch tr√°i");
}

void moveRight() {
  digitalWrite(rightIN1, LOW);
  digitalWrite(rightIN2, HIGH);
  digitalWrite(leftIN3, LOW);
  digitalWrite(leftIN4, HIGH);
  ledcWrite(pwmChannelRight, dutyCycle / 2);
  ledcWrite(pwmChannelLeft, dutyCycle);
  Serial.println("‚û°Ô∏è D·ªãch ph·∫£i");
}

void setSpeed(int speed) {
  if (speed >= 0 && speed <= 255) {
    dutyCycle = speed;
    ledcWrite(pwmChannelRight, dutyCycle);
    ledcWrite(pwmChannelLeft, dutyCycle);
    Serial.print("‚öôÔ∏è T·ªëc ƒë·ªô: ");
    Serial.println(dutyCycle);
  }
}

// B·∫Øt ƒë·∫ßu ch·∫ø ƒë·ªô t·ª± h√†nh
void startAutoMode() {
  autoModeEnabled = true;
  autoModeStep = 0;
  inPauseState = false;
  
  Serial.println("ü§ñ Ch·∫ø ƒë·ªô t·ª± h√†nh ƒë∆∞·ª£c k√≠ch ho·∫°t");
  
  // B·∫Øt ƒë·∫ßu b∆∞·ªõc ƒë·∫ßu ti√™n: ƒëi th·∫≥ng 20 b∆∞·ªõc
  autoModeStep = 1;
  startEncoderCount = encoderCount;
  targetEncoderCount = startEncoderCount + 20;
  moveForward();
  currentState = "auto_mode";
  
  // G·ª≠i th√¥ng b√°o qua MQTT
  client.publish("mpu6050/status", "Auto mode activated - Step 1: Moving forward 20 steps");
}

// Ki·ªÉm tra v√† ƒëi·ªÅu ch·ªânh qu√° tr√¨nh t·ª± ƒë·ªông di chuy·ªÉn - c∆° ch·∫ø kh√¥ng ch·∫∑n
void checkAutoMode() {
  if (!autoModeEnabled) return;
  
  unsigned long currentTime = millis();
  long currentCount = encoderCount;
  
  // Ki·ªÉm tra xem c√≥ ƒëang trong tr·∫°ng th√°i d·ª´ng kh√¥ng
  if (inPauseState) {
    if (currentTime - stateChangeTime >= pauseDuration) {
      inPauseState = false;
      
      // Chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo sau khi d·ª´ng xong
      if (autoModeStep == 1) {
        // B·∫Øt ƒë·∫ßu b∆∞·ªõc 2: quay tr√°i 10 b∆∞·ªõc
        autoModeStep = 2;
        startEncoderCount = currentCount;
        targetEncoderCount = startEncoderCount + 10;
        turnLeft();
        
        Serial.println("ü§ñ B·∫Øt ƒë·∫ßu b∆∞·ªõc 2 - Quay tr√°i 10 b∆∞·ªõc");
        client.publish("mpu6050/status", "Step 2: Turning left 10 steps");
      }
      else if (autoModeStep == 2) {
        // B·∫Øt ƒë·∫ßu b∆∞·ªõc 3: ƒëi th·∫≥ng 20 b∆∞·ªõc
        autoModeStep = 3;
        startEncoderCount = currentCount;
        targetEncoderCount = startEncoderCount + 20;
        moveForward();
        
        Serial.println("ü§ñ B·∫Øt ƒë·∫ßu b∆∞·ªõc 3 - ƒêi th·∫≥ng 20 b∆∞·ªõc");
        client.publish("mpu6050/status", "Step 3: Moving forward 20 steps");
      }
    }
    // N·∫øu ƒëang trong tr·∫°ng th√°i d·ª´ng, kh√¥ng l√†m g√¨ th√™m
    return;
  }
  
  // Ki·ªÉm tra t·ª´ng b∆∞·ªõc n·∫øu kh√¥ng trong tr·∫°ng th√°i d·ª´ng
  switch(autoModeStep) {
    case 1: // ƒêi th·∫≥ng 20 b∆∞·ªõc
      if (currentCount >= targetEncoderCount) {
        stop();
        stateChangeTime = currentTime;
        inPauseState = true;
        
        Serial.println("ü§ñ Ho√†n th√†nh b∆∞·ªõc 1 - ƒêi th·∫≥ng 20 b∆∞·ªõc");
        Serial.println("ü§ñ ƒêang d·ª´ng 1 gi√¢y");
      }
      break;
      
    case 2: // Quay tr√°i 10 b∆∞·ªõc
      if (currentCount >= targetEncoderCount) {
        stop();
        stateChangeTime = currentTime;
        inPauseState = true;
        
        Serial.println("ü§ñ Ho√†n th√†nh b∆∞·ªõc 2 - Quay tr√°i 10 b∆∞·ªõc");
        Serial.println("ü§ñ ƒêang d·ª´ng 1 gi√¢y");
      }
      break;
      
    case 3: // ƒêi th·∫≥ng 20 b∆∞·ªõc
      if (currentCount >= targetEncoderCount) {
        stop();
        
        // K·∫øt th√∫c ch·∫ø ƒë·ªô t·ª± h√†nh
        autoModeEnabled = false;
        currentState = "stop";
        
        Serial.println("ü§ñ Ho√†n th√†nh b∆∞·ªõc 3 - ƒêi th·∫≥ng 20 b∆∞·ªõc");
        Serial.println("ü§ñ Ch·∫ø ƒë·ªô t·ª± h√†nh ho√†n t·∫•t");
        client.publish("mpu6050/status", "Auto mode completed");
      }
      break;
  }
}

void printMenu() {
  Serial.println("===== MENU XE MQTT =====");
  Serial.println("L·ªánh: forward | backward | left | right | stop | move_left | move_right | auto");
  Serial.println("========================");
}

// ====== WiFi / MQTT Setup ======
void setup_wifi() {
  WiFi.begin(ssid, password);
  Serial.print("ƒêang k·∫øt n·ªëi WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\n‚úÖ ƒê√£ k·∫øt n·ªëi WiFi");
}

void callback(char* topic, byte* payload, unsigned int length) {
  String msg = "";
  for (unsigned int i = 0; i < length; i++) {
    msg += (char)payload[i];
  }

  Serial.print("üì© Nh·∫≠n t·ª´ topic [");
  Serial.print(topic);
  Serial.print("]: ");
  Serial.println(msg);

  if (String(topic) == "mpu6050/alert") {
    mqttCommand = msg;
  }
}

void reconnect() { 
  while (!client.connected()) {
    Serial.print("ƒêang k·∫øt n·ªëi MQTT...");
    if (client.connect("ESP32Client", "hiep", "1234")) {
      Serial.println("‚úÖ MQTT k·∫øt n·ªëi");
      client.subscribe("mpu6050/alert");
    } else {
      Serial.print("‚ùå Th·∫•t b·∫°i, m√£ l·ªói: ");
      Serial.println(client.state());
      delay(2000);
    }
  }
}

// H√†m t√≠nh to√°n v√† g·ª≠i t·ªïng s·ªë v√≤ng quay - s·ª≠a ƒë·ªïi ƒë·ªÉ ƒë·∫£m b·∫£o g·ª≠i li√™n t·ª•c
void publishTotalRotations() {
  unsigned long currentTime = millis();
  
  if (currentTime - lastPublishTime >= publishInterval) {
    // L∆∞u th·ªùi ƒëi·ªÉm g·ª≠i ngay t·∫°i ƒë√¢y
    lastPublishTime = currentTime;
    
    // Sao ch√©p gi√° tr·ªã encoderCount ƒë·ªÉ tr√°nh thay ƒë·ªïi trong qu√° tr√¨nh g·ª≠i
    long currentEncoderCount = encoderCount;
    
    // Chuy·ªÉn th√†nh chu·ªói ƒë·ªÉ g·ª≠i MQTT
    char rotationStr[10];
    dtostrf(currentEncoderCount, 2, 0, rotationStr);
    
    // In ra Serial tr∆∞·ªõc khi g·ª≠i MQTT
    Serial.print("üìä T·ªïng s·ªë encoder: ");
    Serial.println(currentEncoderCount);
    
    // G·ª≠i d·ªØ li·ªáu encoder ngay l·∫≠p t·ª©c n·∫øu ƒë√£ k·∫øt n·ªëi
    if (client.connected()) {
      client.publish("mpu6050/vongquay", rotationStr);
    }
  }
}

// ====== Setup & Loop ======
void setup() {
  Serial.begin(9600);
  setup_wifi();

  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);

  pinMode(rightIN1, OUTPUT);
  pinMode(rightIN2, OUTPUT);
  pinMode(leftIN3, OUTPUT);
  pinMode(leftIN4, OUTPUT);
  pinMode(rightEnable, OUTPUT);
  pinMode(leftEnable, OUTPUT);

  // Thi·∫øt l·∫≠p encoder pin v√† ng·∫Øt
  pinMode(encoderPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(encoderPin), encoderISR, RISING);

  ledcSetup(pwmChannelRight, freq, resolution);
  ledcAttachPin(rightEnable, pwmChannelRight);
  ledcSetup(pwmChannelLeft, freq, resolution);
  ledcAttachPin(leftEnable, pwmChannelLeft);

  stop();
  printMenu();
}

void loop() {
  // ƒê·∫£m b·∫£o k·∫øt n·ªëi MQTT
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // X·ª≠ l√Ω l·ªánh ƒëi·ªÅu khi·ªÉn
  if (mqttCommand.length() > 0) {
    String cmd = mqttCommand;
    mqttCommand = "";  // clear ƒë·ªÉ kh√¥ng b·ªã l·∫∑p l·∫°i

    cmd.toLowerCase();
    
    // X·ª≠ l√Ω l·ªánh auto mode ƒë·∫∑c bi·ªát
    if (cmd == "auto") {
      startAutoMode();
    }
    // Ch·ªâ x·ª≠ l√Ω c√°c l·ªánh kh√°c n·∫øu kh√¥ng ·ªü trong ch·∫ø ƒë·ªô t·ª± ƒë·ªông
    else if (!autoModeEnabled && cmd != currentState) {
      currentState = cmd; // C·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªán t·∫°i
      
      if (cmd == "forward") moveForward();
      else if (cmd == "backward") moveBackward();
      else if (cmd == "left") turnLeft();
      else if (cmd == "right") turnRight();
      else if (cmd == "move_left") moveLeft();
      else if (cmd == "move_right") moveRight();
      else if (cmd == "stop") stop();
      else if (cmd == "help") printMenu();
      else {
        Serial.print("‚ùì L·ªánh kh√¥ng h·ª£p l·ªá: ");
        Serial.println(cmd);
        currentState = ""; // Reset state for invalid commands
      }
    } else if (!autoModeEnabled) {
      Serial.println("üîÑ Gi·ªØ nguy√™n tr·∫°ng th√°i: " + currentState);
    } else {
      Serial.println("ü§ñ ƒêang ·ªü ch·∫ø ƒë·ªô t·ª± h√†nh, b·ªè qua l·ªánh: " + cmd);
    }
  }

  // Ki·ªÉm tra v√† c·∫≠p nh·∫≠t ch·∫ø ƒë·ªô t·ª± h√†nh n·∫øu ƒë∆∞·ª£c k√≠ch ho·∫°t
  checkAutoMode();

  // G·ª≠i t·ªïng s·ªë v√≤ng quay - ƒë∆∞·ª£c g·ªçi th∆∞·ªùng xuy√™n trong loop
  publishTotalRotations();

}